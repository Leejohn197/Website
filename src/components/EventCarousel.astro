---
// EventCarousel.astro - Custom carousel component for event images
interface Props {
  images: string[];
  autoplayInterval?: number;
}

const { images, autoplayInterval = 5000 } = Astro.props;
---

<div class="event-carousel relative w-full overflow-hidden rounded-2xl shadow-2xl" data-autoplay-interval={autoplayInterval}>
  <!-- Carousel Container -->
  <div class="carousel-track flex transition-transform duration-700 ease-in-out">
    {images.map((image, index) => (
      <div class="carousel-slide min-w-full h-[400px] md:h-[500px] lg:h-[600px] relative">
        <img 
          src={image} 
          alt={`Event ${index + 1}`}
          class="w-full h-full object-cover"
          loading={index === 0 ? "eager" : "lazy"}
        />
        <!-- Gradient Overlay for better text visibility -->
        <div class="absolute inset-0 bg-gradient-to-t from-black/50 via-transparent to-transparent"></div>
      </div>
    ))}
  </div>

  <!-- Navigation Arrows -->
  <button 
    class="carousel-prev absolute left-4 top-1/2 -translate-y-1/2 bg-white/90 hover:bg-white text-primary-900 p-3 rounded-full shadow-lg transition-all duration-300 hover:scale-110 focus:outline-none focus:ring-4 focus:ring-secondary-500/50 z-10"
    aria-label="Previous slide"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 19l-7-7 7-7"></path>
    </svg>
  </button>
  
  <button 
    class="carousel-next absolute right-4 top-1/2 -translate-y-1/2 bg-white/90 hover:bg-white text-primary-900 p-3 rounded-full shadow-lg transition-all duration-300 hover:scale-110 focus:outline-none focus:ring-4 focus:ring-secondary-500/50 z-10"
    aria-label="Next slide"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M9 5l7 7-7 7"></path>
    </svg>
  </button>

  <!-- Indicators -->
  <div class="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-3 z-10">
    {images.map((_, index) => (
      <button 
        class="carousel-indicator w-3 h-3 rounded-full bg-white/50 hover:bg-white/80 transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-white/80"
        data-index={index}
        aria-label={`Go to slide ${index + 1}`}
      ></button>
    ))}
  </div>

  <!-- Pause/Play Button -->
  <button 
    class="carousel-toggle absolute top-4 right-4 bg-white/90 hover:bg-white text-primary-900 p-2 rounded-full shadow-lg transition-all duration-300 hover:scale-110 focus:outline-none focus:ring-4 focus:ring-secondary-500/50 z-10"
    aria-label="Toggle autoplay"
  >
    <svg class="carousel-pause-icon w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
      <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"></path>
    </svg>
    <svg class="carousel-play-icon w-5 h-5 hidden" fill="currentColor" viewBox="0 0 24 24">
      <path d="M8 5v14l11-7z"></path>
    </svg>
  </button>
</div>

<script is:inline>
  class EventCarousel {
    constructor(element) {
      this.carousel = element;
      this.track = this.carousel.querySelector('.carousel-track');
      this.slides = this.carousel.querySelectorAll('.carousel-slide');
      this.prevBtn = this.carousel.querySelector('.carousel-prev');
      this.nextBtn = this.carousel.querySelector('.carousel-next');
      this.indicators = this.carousel.querySelectorAll('.carousel-indicator');
      this.toggleBtn = this.carousel.querySelector('.carousel-toggle');
      this.pauseIcon = this.carousel.querySelector('.carousel-pause-icon');
      this.playIcon = this.carousel.querySelector('.carousel-play-icon');
      
      console.log('[EventCarousel] Constructor called');
      
      if (!this.track || !this.slides.length) {
        console.error('[EventCarousel] Critical elements missing');
        return;
      }

      this.currentIndex = 0;
      this.totalSlides = this.slides.length;
      this.autoplayInterval = parseInt(this.carousel.dataset.autoplayInterval) || 5000;
      this.autoplayTimer = null;
      this.isPlaying = true;
      
      this.init();
    }
    
    init() {
      // Set initial active indicator
      this.updateIndicators();
      
      // Event listeners
      if (this.prevBtn) this.prevBtn.addEventListener('click', () => this.prev());
      if (this.nextBtn) this.nextBtn.addEventListener('click', () => this.next());
      if (this.toggleBtn) this.toggleBtn.addEventListener('click', () => this.toggleAutoplay());
      
      this.indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => this.goToSlide(index));
      });
      
      // Touch/swipe support
      let touchStartX = 0;
      let touchEndX = 0;
      
      this.carousel.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
      });
      
      this.carousel.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        this.handleSwipe(touchStartX, touchEndX);
      });
      
      // Pause on hover
      this.carousel.addEventListener('mouseenter', () => {
        if (this.isPlaying) {
          this.pauseAutoplay();
        }
      });
      
      this.carousel.addEventListener('mouseleave', () => {
        if (this.isPlaying) {
          this.startAutoplay();
        }
      });
      
      // Start autoplay
      this.startAutoplay();
      console.log('[EventCarousel] Initialized successfully');
    }
    
    goToSlide(index) {
      this.currentIndex = index;
      this.updateCarousel();
    }
    
    next() {
      this.currentIndex = (this.currentIndex + 1) % this.totalSlides;
      this.updateCarousel();
    }
    
    prev() {
      this.currentIndex = (this.currentIndex - 1 + this.totalSlides) % this.totalSlides;
      this.updateCarousel();
    }
    
    updateCarousel() {
      const offset = -this.currentIndex * 100;
      this.track.style.transform = `translateX(${offset}%)`;
      this.updateIndicators();
    }
    
    updateIndicators() {
      this.indicators.forEach((indicator, index) => {
        if (index === this.currentIndex) {
          indicator.classList.remove('bg-white/50');
          indicator.classList.add('bg-white', 'scale-125');
        } else {
          indicator.classList.remove('bg-white', 'scale-125');
          indicator.classList.add('bg-white/50');
        }
      });
    }
    
    handleSwipe(startX, endX) {
      const swipeThreshold = 50;
      const diff = startX - endX;
      
      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          this.next();
        } else {
          this.prev();
        }
      }
    }
    
    startAutoplay() {
      this.pauseAutoplay(); // Clear any existing timer
      this.autoplayTimer = setInterval(() => {
        this.next();
      }, this.autoplayInterval);
    }
    
    pauseAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
    }
    
    toggleAutoplay() {
      this.isPlaying = !this.isPlaying;
      
      if (this.isPlaying) {
        this.pauseIcon.classList.remove('hidden');
        this.playIcon.classList.add('hidden');
        this.startAutoplay();
      } else {
        this.pauseIcon.classList.add('hidden');
        this.playIcon.classList.remove('hidden');
        this.pauseAutoplay();
      }
    }
  }
  
  // Robust Initialization Logic
  function initEventCarousels() {
    console.log('[EventCarousel] Scanning for carousels...');
    const carousels = document.querySelectorAll('.event-carousel');
    console.log(`[EventCarousel] Found ${carousels.length} elements`);
    
    carousels.forEach((carousel, index) => {
      if (carousel.dataset.initialized === 'true') {
        return; 
      }
      
      console.log(`[EventCarousel] Initializing instance #${index + 1}`);
      try {
        new EventCarousel(carousel);
        carousel.dataset.initialized = 'true';
      } catch (err) {
        console.error('[EventCarousel] Initialization error:', err);
      }
    });
  }

  // Support both DOMContentLoaded and immediate execution
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEventCarousels);
  } else {
    initEventCarousels();
  }
  
  // Support Astro View Transitions
  document.addEventListener('astro:page-load', initEventCarousels);
</script>

<style is:global>
  .carousel-indicator.bg-white {
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
  }
  
  /* Fallback styles in case Tailwind JIT misses the arbitrary values */
  .carousel-slide {
    height: 400px;
  }
  @media (min-width: 768px) {
    .carousel-slide {
      height: 500px;
    }
  }
  @media (min-width: 1024px) {
    .carousel-slide {
      height: 600px;
    }
  }
</style>
